{"contentString":"/** \n * {@inheritDoc}The default implementation returns <ul> <li> {@link #getSupportLowerBound()} for {@code p = 0},</li> <li> {@link #getSupportUpperBound()} for {@code p = 1}, and</li> <li> {@link #solveInverseCumulativeProbability(double,int,int)} for{@code 0 < p < 1}.</li> </ul>\n */\npublic int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n  if (p < 0.0 || p > 1.0) {\n    throw new OutOfRangeException(p,0,1);\n  }\n  int lower=getSupportLowerBound();\n  if (p == 0.0) {\n    return lower;\n  }\n  if (lower == Integer.MIN_VALUE) {\n    if (checkedCumulativeProbability(lower) >= p) {\n      return lower;\n    }\n  }\n else {\n    lower-=1;\n  }\n  int upper=getSupportUpperBound();\n  if (p == 1.0) {\n    return upper;\n  }\n  final double mu=getNumericalMean();\n  final double sigma=FastMath.sqrt(getNumericalVariance());\n  final boolean chebyshevApplies=!(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sigma)|| Double.isNaN(sigma)|| sigma == 0.0);\n  if (chebyshevApplies) {\n    double k=FastMath.sqrt((1.0 - p) / p);\n    double tmp=mu - k * sigma;\n    if (tmp > lower) {\n      lower=((int)Math.ceil(tmp)) - 1;\n    }\n    k=1.0 / k;\n    tmp=mu + k * sigma;\n    if (tmp < upper) {\n      upper=((int)Math.ceil(tmp)) - 1;\n    }\n  }\n  return solveInverseCumulativeProbability(p,lower,upper);\n}\n","endLine":143,"fixedFile":"/home/xushicheng/dataset/defects4j/projects/Math/Math_2_buggy/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java","methodName":"org.apache.commons.math3.distribution.AbstractIntegerDistribution#int#inverseCumulativeProbability#?,double","startLine":100}